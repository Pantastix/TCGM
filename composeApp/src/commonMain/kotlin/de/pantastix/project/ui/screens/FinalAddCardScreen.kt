package de.pantastix.project.ui.screens

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.text.ClickableText
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import de.pantastix.project.model.api.TcgDexCardResponse
import androidx.compose.ui.Alignment
import androidx.compose.ui.platform.LocalUriHandler
import androidx.compose.ui.text.SpanStyle
import androidx.compose.ui.text.buildAnnotatedString
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.withStyle
import coil3.compose.AsyncImage
import de.pantastix.project.model.SetInfo
import de.pantastix.project.shared.resources.MR
import dev.icerock.moko.resources.compose.stringResource
import jdk.internal.org.jline.utils.AttributedStringBuilder.append
import org.jetbrains.compose.ui.tooling.preview.Preview

enum class PriceSchema {
    TREND,
    AVG1,
    AVG7,
    AVG30,
    LOW
}

@Composable
fun FinalAddCardScreen(
    cardDetails: TcgDexCardResponse,
    englishCardDetails: TcgDexCardResponse?,
    setInfo: SetInfo?,
    isLoading: Boolean,
    onConfirm: (
        cardDetails: TcgDexCardResponse,
        editedName: String,
        abbreviation: String?,
        price: Double?,
        marketLink: String,
        quantity: Int,
        notes: String?,
        selectedPriceSource: String?,
    ) -> Unit,
    onCancel: () -> Unit
) {
    var priceInput by remember { mutableStateOf("") }
    var abbreviationInput by remember(setInfo?.abbreviation) { mutableStateOf(setInfo?.abbreviation ?: "") }
    var quantityInput by remember { mutableStateOf("1") }
    var notesInput by remember { mutableStateOf("") }
    var linkInput by remember { mutableStateOf("") }
    var userHasEditedLink by remember { mutableStateOf(false) }

    var selectedPriceSchema by remember { mutableStateOf<PriceSchema?>(null) }
    var isHolo by remember { mutableStateOf(false) }

    fun updatePrice(priceSchema: PriceSchema? = selectedPriceSchema, isHoloCard: Boolean = isHolo) {
        val pricing = cardDetails.pricing?.cardmarket
        if (pricing != null) {
            val priceToSet = if (isHoloCard) {
                when (priceSchema) {
                    PriceSchema.TREND -> pricing.`trend-holo`
                    PriceSchema.AVG1 -> pricing.`avg1-holo`
                    PriceSchema.AVG7 -> pricing.`avg7-holo`
                    PriceSchema.AVG30 -> pricing.`avg30-holo`
                    PriceSchema.LOW -> pricing.`low-holo`
                    else -> null
                }
            } else {
                when (priceSchema) {
                    PriceSchema.TREND -> pricing.trend
                    PriceSchema.AVG1 -> pricing.avg1
                    PriceSchema.AVG7 -> pricing.avg7
                    PriceSchema.AVG30 -> pricing.avg30
                    PriceSchema.LOW -> pricing.low
                    else -> null
                }
            }
            if (priceToSet != null) {
                priceInput = String.format("%.2f", priceToSet)
            } else {
                priceInput = "" // Setze leer, wenn kein Preis verfügbar ist
            }
        } else {
            priceInput = ""
        }
    }

    LaunchedEffect(cardDetails) {
        val pricing = cardDetails.pricing?.cardmarket
        val trendPrice = if (isHolo) pricing?.`trend-holo` else pricing?.trend
        if (trendPrice != null) {
            priceInput = String.format("%.2f", trendPrice)
            selectedPriceSchema = PriceSchema.TREND
        }
    }

    LaunchedEffect(abbreviationInput, cardDetails, englishCardDetails, setInfo) {
        if (!userHasEditedLink) {
            fun slugify(input: String) = input.replace("'", "")
                .replace(" ", "-")
                .replace(":", "")
                .replace("&", "")
                .replace(Regex("--+"), "-")

            val versionSuffix = cardDetails.cardmarketVersion?.let { version ->
                // Annahme: cardDetails hat jetzt ein Feld `totalCardmarketVersions`
                val totalVersions = cardDetails.totalCardmarketVersions ?: 1
                if (totalVersions > 1) {
                    "-V$version"
                } else {
                    "" // Kein Suffix, wenn es nur eine Version gibt.
                }
            } ?: ""

            // Fügt den Suffix zum slugifizierten Kartennamen hinzu.
            val cardNameToUse = englishCardDetails?.name ?: cardDetails.name
            val slugifiedCardNameWithVersion = "${slugify(cardNameToUse)}${versionSuffix}"

            val finalAbbreviation =
                if (abbreviationInput.isNotBlank()) abbreviationInput.uppercase() else cardDetails.set.id.uppercase()

            val autoGeneratedLink = "https://www.cardmarket.com/de/Pokemon/Products/Singles/" +
                    "${slugify(setInfo?.nameEn ?: cardDetails.set.name)}/" +
                    "${slugifiedCardNameWithVersion}-${finalAbbreviation}${cardDetails.localId}"

            linkInput = autoGeneratedLink
        }
    }

    var nameInput by remember(cardDetails.name) { mutableStateOf(cardDetails.name) }

    Column(modifier = Modifier.fillMaxSize().verticalScroll(rememberScrollState()).padding(16.dp)) {
        Text(
            text = cardDetails.name,
            style = MaterialTheme.typography.headlineMedium,
            modifier = Modifier.fillMaxWidth().padding(bottom = 8.dp)
        )
        Text(
            "${cardDetails.set.name} (${cardDetails.localId}/${setInfo?.cardCountOfficial})",
            style = MaterialTheme.typography.headlineSmall,
            modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp)
        )

        AsyncImage(
            model = cardDetails.image?.let { "$it/high.jpg" },
            contentDescription = cardDetails.name,
            modifier = Modifier.fillMaxWidth().height(250.dp).align(Alignment.CenterHorizontally)
        )
        Spacer(Modifier.height(16.dp))

        Text(
            stringResource(MR.strings.final_add_card_found_title),
            style = MaterialTheme.typography.headlineSmall,
            modifier = Modifier.padding(bottom = 8.dp)
        )

        OutlinedTextField(
            value = nameInput,
            onValueChange = { nameInput = it },
            readOnly = false,
            label = { Text(stringResource(MR.strings.final_add_card_name_label)) },
            modifier = Modifier.fillMaxWidth()
        )

        println("Set Info-Abbreviation: ${setInfo?.abbreviation}")
        if (setInfo?.abbreviation == null) {
            OutlinedTextField(
                value = abbreviationInput,
                onValueChange = { abbreviationInput = it },
                label = { Text(stringResource(MR.strings.final_add_card_set_abbr_label)) },
                modifier = Modifier.fillMaxWidth(),
                supportingText = { Text(stringResource(MR.strings.final_add_card_set_abbr_support)) }
            )
        }

        OutlinedTextField(
            value = linkInput,
            onValueChange = {
                linkInput = it
                userHasEditedLink = true
            },
            readOnly = false,
            label = { Text(stringResource(MR.strings.final_add_card_cardmarket_link_label)) },
            modifier = Modifier.fillMaxWidth()
        )

        val uriHandler = LocalUriHandler.current
        TextButton(onClick = { uriHandler.openUri(linkInput) }, modifier = Modifier.align(Alignment.End)) {
            Text(stringResource(MR.strings.final_add_card_open_on_cardmarket))
        }

        HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))

        Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
            OutlinedTextField(
                value = priceInput,
                onValueChange = {
                    priceInput = it
                    selectedPriceSchema = null
                },
                label = { Text(stringResource(MR.strings.final_add_card_purchase_price_label)) },
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                modifier = Modifier.weight(1f)
            )
            OutlinedTextField(
                value = quantityInput,
                onValueChange = { quantityInput = it.filter { char -> char.isDigit() } },
                label = { Text(stringResource(MR.strings.final_add_card_quantity_label)) },
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                modifier = Modifier.weight(0.5f)
            )
        }

        Spacer(Modifier.height(8.dp))

        Text(
            text = stringResource(MR.strings.final_add_card_pricing_warning),
            modifier = Modifier.padding(bottom = 8.dp),
            //color grey
            style = MaterialTheme.typography.bodyMedium.copy(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f))
        )
        // Preis-Schema-Buttons
        val hasPricingData = cardDetails.pricing?.cardmarket != null
        if (hasPricingData) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(8.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                // Holo/Non-Holo Auswahl
                OutlinedButton(
                    onClick = {
                        isHolo = false
                        updatePrice(selectedPriceSchema, false)
                    },
                    modifier = Modifier.weight(1f),
                    colors = if (!isHolo) ButtonDefaults.outlinedButtonColors(containerColor = MaterialTheme.colorScheme.primaryContainer) else ButtonDefaults.outlinedButtonColors()
                ) {
                    Text("Normal")
                }
                OutlinedButton(
                    onClick = {
                        isHolo = true
                        updatePrice(selectedPriceSchema, true)
                    },
                    modifier = Modifier.weight(1f),
                    colors = if (isHolo) ButtonDefaults.outlinedButtonColors(containerColor = MaterialTheme.colorScheme.primaryContainer) else ButtonDefaults.outlinedButtonColors()
                ) {
                    Text("Holo")
                }
            }

            Spacer(Modifier.height(8.dp))

            // Preis-Schema-Buttons in zwei Zeilen
            val priceButtons = listOf(
                Pair(PriceSchema.TREND, "Trend"),
                Pair(PriceSchema.LOW, "Low"),
                Pair(PriceSchema.AVG1, "Avg 1"),
                Pair(PriceSchema.AVG7, "Avg 7"),
                Pair(PriceSchema.AVG30, "Avg 30")
            )
            val firstRowButtons = priceButtons.subList(0, 3)
            val secondRowButtons = priceButtons.subList(3, priceButtons.size)

            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                // Erste Zeile der Buttons
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    firstRowButtons.forEach { (schema, label) ->
                        val price = if (isHolo) {
                            when (schema) {
                                PriceSchema.TREND -> cardDetails.pricing?.cardmarket?.`trend-holo`
                                PriceSchema.LOW -> cardDetails.pricing?.cardmarket?.`low-holo`
                                PriceSchema.AVG1 -> cardDetails.pricing?.cardmarket?.`avg1-holo`
                                else -> null
                            }
                        } else {
                            when (schema) {
                                PriceSchema.TREND -> cardDetails.pricing?.cardmarket?.trend
                                PriceSchema.LOW -> cardDetails.pricing?.cardmarket?.low
                                PriceSchema.AVG1 -> cardDetails.pricing?.cardmarket?.avg1
                                else -> null
                            }
                        }

                        if (price != null) {
                            OutlinedButton(
                                onClick = {
                                    selectedPriceSchema = schema
                                    updatePrice(schema)
                                },
                                colors = if (selectedPriceSchema == schema) ButtonDefaults.outlinedButtonColors(
                                    containerColor = MaterialTheme.colorScheme.primaryContainer
                                ) else ButtonDefaults.outlinedButtonColors()
                            ) {
                                Text("$label: ${String.format("%.2f", price)}€")
                            }
                        }
                    }
                }
                // Zweite Zeile der Buttons
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    secondRowButtons.forEach { (schema, label) ->
                        val price = if (isHolo) {
                            when (schema) {
                                PriceSchema.AVG7 -> cardDetails.pricing?.cardmarket?.`avg7-holo`
                                PriceSchema.AVG30 -> cardDetails.pricing?.cardmarket?.`avg30-holo`
                                else -> null
                            }
                        } else {
                            when (schema) {
                                PriceSchema.AVG7 -> cardDetails.pricing?.cardmarket?.avg7
                                PriceSchema.AVG30 -> cardDetails.pricing?.cardmarket?.avg30
                                else -> null
                            }
                        }

                        if (price != null) {
                            OutlinedButton(
                                onClick = {
                                    selectedPriceSchema = schema
                                    updatePrice(schema)
                                },
                                colors = if (selectedPriceSchema == schema) ButtonDefaults.outlinedButtonColors(
                                    containerColor = MaterialTheme.colorScheme.primaryContainer
                                ) else ButtonDefaults.outlinedButtonColors()
                            ) {
                                Text("$label: ${String.format("%.2f", price)}€")
                            }
                        }
                    }
                }
            }
        }

        HorizontalDivider(
            modifier = Modifier.padding(vertical = 8.dp),
        )

        OutlinedTextField(
            value = notesInput,
            onValueChange = { notesInput = it },
            label = { Text(stringResource(MR.strings.final_add_card_notes_label)) },
            modifier = Modifier.fillMaxWidth().height(100.dp)
        )

        Spacer(Modifier.weight(1f))

        Box(contentAlignment = Alignment.Center, modifier = Modifier.fillMaxWidth()) {
            if (isLoading) {
                CircularProgressIndicator()
            } else {
                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                    OutlinedButton(
                        onClick = onCancel,
                        modifier = Modifier.weight(1f)
                    ) { Text(stringResource(MR.strings.final_add_card_cancel_button)) }
                    Button(
                        onClick = {
                            val quantity = quantityInput.toIntOrNull() ?: 1

                            val priceSource = when {
                                selectedPriceSchema != null -> {
                                    val baseName = selectedPriceSchema!!.name.lowercase()
                                    if (isHolo) "${baseName}-holo" else baseName
                                }
                                priceInput.isNotBlank() -> "CUSTOM"
                                else -> null
                            }

                            onConfirm(
                                cardDetails,
                                nameInput,
                                abbreviationInput.ifBlank { null },
                                priceInput.replace(",", ".").toDoubleOrNull(),
                                linkInput,
                                quantity,
                                notesInput.ifBlank { null },
                                priceSource,
                            )
                        },
                        modifier = Modifier.weight(1f)
                    ) {
                        Text(stringResource(MR.strings.final_add_card_save_button))
                    }
                }
            }
        }
    }
}